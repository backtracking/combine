\documentclass[french,frtypo,twoside,actes,a4paper]{article}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{actes,hyperref,graphicx}

\newcommand{\combine}{\texttt{combine}}
\newcommand{\noeud}{n\oe ud}
\newcommand{\noeuds}{n\oe uds}

\newcommand{\te}[1]{\texttt{#1}}
\newcommand{\nt}[1]{$\langle$\textsl{#1}$\rangle$}
\newcommand{\etoile}{$^{\star}$}
\newcommand{\etoilesep}[1]{$^{\star}_#1$}
\newcommand{\plus}{$^+$}
\newcommand{\plussep}[1]{$^+_#1$}
\newcommand{\OU}{\ensuremath{\mid}}

%% Title page...
\title{\combine\ : une bibliothèque OCaml pour la combinatoire}
\author{Rémy El Sibaïe$^1$
  \& Jean-Christophe Filliâtre$^{2,1}$}
%% Headers for other pages...
\titlehead{\combine\ : une bibliothèque OCaml pour la combinatoire} % for odd pages
\authorhead{R.~El Sibaie \& J.-C. Filliâtre}     % for even pages
\affiliation{\begin{tabular}{rr}        % for institute(s)
    \\ 1:  LRI, Université Paris Sud,
    \\     91405 Orsay CEDEX, France
    \\ 2:  CNRS,
    \\     {\tt remy.el-sibaie@u-psud.fr}
    \\     {\tt jean-christophe.filliatre@lri.fr}
  \end{tabular}}

\input{./insbox}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

\setcounter{page}{1}
\maketitle

\begin{abstract}
  Cet article présente \combine\footnote{Le lecteur perspicace notera
    que \combine\ est à la fois un mot anglais, français et un anagramme
    de << combien >>.}, une bibliothèque OCaml pour la
  combinatoire\footnote{Il s'agit d'un travail réalisé par le premier
    auteur pendant un stage de L3 au LRI, d'avril à juin 2012, sous la
    direction du second auteur.}. Elle fournit deux solutions
  algorithmiques très différentes au problème de la couverture exacte
  de matrice (EMC) : les liens dansants de Knuth et une variante
  des diagrammes de décision binaire appelée ZDD. De très nombreux
  problèmes de combinatoire peuvent être ramenés au problème EMC. La
  bibliothèque \combine\ l'illustre notamment avec le pavage
  rectangulaire en dimension 2.
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}

\InsertBoxR{1}{\includegraphics{caml_problem.mps}}
Rien n'est plus excitant en informatique que d'écrire un programme
qui calcule en quelques secondes un résultat qu'on ne pourrait obtenir
sans l'aide d'un ordinateur. La combinatoire est un domaine
particulièrement fertile en la matière. Si certains problèmes se
prêtent volontiers à l'analyse mathématique, comme le nombre total de livres
dans la bibliothèque de Borgès ou encore le nombre de
labyrinthes parfaits rectangulaires, beaucoup d'autres exigent de
recourir à la programmation. Considérons par exemple le
nombre de façons différentes de paver
la figure ci-contre avec des dominos $2\times 1$.
Il est relativement aisé d'écrire un programme qui va explorer toutes
les solutions possibles. En une fraction de seconde, on déterminera
alors qu'elles sont au nombre de 46\,976.
% (ZDD 0.11s, DLX 0.09s)

\InsertBoxL{0}{\includegraphics{caml2_problem.mps}}
Mais considérons maintenant un problème de pavage légèrement plus
complexe, avec la figure de gauche qui demande deux fois plus de dominos.
Le problème est nettement plus difficile. Une approche brutale, qui
trouve les solutions une à une, n'aboutira pas. Il existe en effet
32\,420\,116\,341\,024\,288 solutions distinctes. Même à raison d'un
milliard de solutions trouvées par seconde, il faudrait encore plus
d'un an pour parvenir à ce chiffre. Et pourtant le chiffre ci-dessus a
été obtenu par les auteurs en quelques dizaines de secondes seulement,
à l'aide d'une bibliothèque OCaml, \combine, qui permet notamment de résoudre des
problèmes de pavage rectangulaires en dimension 2.
Cet article a pour but de présenter cette bibliothèque.
% (ZDD 39.7s, 1.4 Go de RAM)

La bibliothèque \combine\ est centrée autour du problème de la
\emph{couverture exacte de matrice}, désigné par EMC dans ce qui suit. Étant
donnée une matrice contenant uniquement des 0 et des 1, il s'agit de
déterminer un sous-ensemble de ses lignes contenant un 1 et un seul
par colonne. Étant donné un problème EMC, on peut s'intéresser
uniquement à la question de savoir s'il possède une solution, au
problème d'en construire une le cas échéant, au problème de dénombrer
les solutions, ou encore au problème de les construire toutes.
Ainsi le problème EMC suivant
\begin{displaymath}
  % \begin{array}{ c }
  %  0. \\
  %  1. \\
  %  2. \\
  %  3. \\
  %  4. \\
  % \end{array}
\left(
  \begin{array}{ c c c c c }
   1 & 0 & 1 & 1 \\
   0 & 1 & 1 & 0 \\
   1 & 1 & 0 & 1 \\
   1 & 0 & 0 & 1 \\
   0 & 1 & 0 & 0
  \end{array} \right)
\end{displaymath}
possède exactement deux solutions, à savoir les sous-ensembles de
lignes $\{0,4\}$ et $\{1,3\}$.
L'intérêt d'EMC est qu'il est très facile d'y encoder de
nombreux problèmes de combinatoire. Ainsi un problème de pavage, tel
que celui présenté en introduction, peut être encodé de la façon
suivante : chaque colonne représente une case à recouvrir et chaque
ligne une façon possible de poser une pièce. Ainsi le petit chameau
donne lieu à une matrice de 80 colonnes et 122 lignes, et le gros
chameau à une matrice de 160 colonnes et 268 lignes.

Pour résoudre le problème EMC, plusieurs techniques sont à notre
disposition. Une première consiste à découvrir les solutions une par
une, en utilisant du \emph{backtracking}.
Knuth a proposé pour cela un algorithme appelé les \emph{liens
  dansants} (ou encore DLX)~\cite{knuth00:dlx}. Il consiste à relier
ensemble tous les
1 de la matrice EMC dans un réseau de listes circulaires doublement
chaînées horizontales et verticales, puis à ôter
successivement les éléments de ces listes, au fur et à mesure des choix
qui sont faits, et à les réinsérer ensuite.
L'efficacité de cet algorithme est due notamment à la
possibilité de réinsérer un élément qui vient d'être supprimé d'une
liste doublement chaînée sans utiliser d'autre information que
celle qui se trouve déjà dans les deux pointeurs vers ses anciens voisins.
L'algorithme DLX ne trouve les solutions du problème EMC qu'une à une,
mais avec une très grande efficacité. Pour le petit chameau, les
46\,976 solutions sont trouvées en un dixième de seconde.

Une second approche du problème EMC consiste à utiliser une variante
des BDD appelée ZDD, pour \emph{Zero-suppressed binary Decision
  Diagram}, et due à Minato~\cite{ZDD}. Comme les BDD, les ZDD
permettent de représenter une fonction booléenne de $n$ variables sous
la forme d'un graphe orienté acyclique. On peut effectuer des
opérations entre ZDD, comme par exemple la conjonction ou la
disjonction, ou encore calculer très simplement le nombre
d'assignations distinctes des $n$ variables qui donne la valeur de
vérité 1. Les ZDD sont décrits en détail dans le volume 4A de
\emph{The Art of Computer Programming}~\cite{taocp4a}.
Le problème EMC peut être réduit à un ZDD de la façon
suivante. Les $n$ variables sont les $n$ lignes de la matrice. On
commence par convertir chaque colonne de la matrice EMC en un ZDD qui
correspond aux sous-ensembles de lignes qui contiennent exactement un
1 dans cette colonne. Puis on fait l'intersection de tous ces
ZDD\footnote{Les ZDD étaient au concours X/ENS en 2012 mais ce n'est,
  bien sûr, que pure coïncidence.}.
Cette technique a les avantages et les inconvénients usuels des BDD. Si on
parvient à construire le ZDD sans épuiser la mémoire vive, alors le
problème est résolu. En effet, on peut alors facilement déterminer
s'il existe une solution, et une construire une le cas échéant, mais
surtout calculer le nombre total de solutions (en exploitant le
partage, comme avec un BDD). C'est ainsi qu'on a calculé le nombre
gigantesque de solutions au problème de pavage du grand chameau.

\InsertBoxR{0}{\includegraphics{caml_solution.mps}}%
La bibliothèque \combine\ contient, outre ces deux solutions au problème
EMC, trois exemples d'application. Les deux premiers sont des exemples
relativement simples. Il s'agit du problème des $N$ reines et du
Sudoku. Le troisième exemple est celui du pavage rectangulaire en
dimension 2. Il se présente sous la forme d'une bibliothèque OCaml
pour décrire un problème de pavage, le réduire à un problème EMC et
interpréter les solutions.
C'est ainsi qu'a été obtenue la solution ci-contre au problème de
pavage donné en introduction\footnote{Ce résultat de pavage a été dessiné
  automatiquement avec la
  bibliothèque OCaml \texttt{mlpost}~\cite{mlpost09jfla}, à partir
  de la solution produite par \combine.}.
Enfin, la distribution de \combine\ contient un interprète pour un petit
langage permettant de décrire un problème de pavage dans une syntaxe
concrète et d'utiliser les différents outils de la bibliothèque
sans recourir à un programme.
La figure~\ref{fig:chameau} contient un exemple d'entrée pour cet
interprète.
%
\begin{figure}[t]
  \centering
  \begin{tabular}{l|l}
    \begin{minipage}{0.4\linewidth}
\begin{verbatim}
pattern caml = {
....****....................
..******....................
********....****..****......
....****....**********......
....****..**************....
....**********************..
....************************
......********....******..**
........****........****....
........****........****....
........****........****....
........****........****....
........****........****....}
\end{verbatim}
    \end{minipage} &
    \begin{minipage}{0.6\linewidth}
\begin{verbatim}
pattern domino = {**}

problem tiling_a_caml = caml [domino ~sym]

timing on

solve dlx tiling_a_caml svg "output.svg"

count zdd tiling_a_caml





\end{verbatim}
    \end{minipage}
  \end{tabular}
  \caption{Exemple d'entrée de l'outil \combine\ (sur deux colonnes).}
\hrulefill
  \label{fig:chameau}
\end{figure}
%
La bibliothèque \combine\ est un logiciel libre, distribué sous licence
LGPL à l'adresse \url{http://www.lri.fr/~filliatr/combine/}.

\insboxrestore
\medskip
Le reste de cet article est organisé de façon très simple. La
section~\ref{sec:sig} présente l'interface de la bibliothèque \combine\
et la section~\ref{sec:impl} les détails techniques de sa
réalisation. L'article s'achève sur quelques extensions possibles.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Interface}\label{sec:sig}

La bibliothèque \combine\ se compose de quatre modules principaux,
organisés de la façon suivante :
\begin{center}
  \includegraphics{archi.mps}
\end{center}
Cette section décrit ces quatre modules, de bas en haut.

\paragraph{\of{Dlx}.}
L'algorithme DLX résout le problème EMC.
Un tel problème est ici matérialisé par un type abstrait \of{Dlx.t}, que l'on
construit à partir d'une matrice de booléens.
\begin{ocaml}
  val create: ?primary:int -> bool array array -> t
\end{ocaml}
On généralise légèrement le problème présenté dans
l'introduction, en distinguant des colonnes primaires qui doivent être
couvertes (un 1 et un seul dans ces colonnes-là) et des colonnes
secondaires qui peuvent ne pas être couvertes (au plus un 1).
L'argument optionnel \of{primary} permet de spécifier que les
\of{primary} premières colonnes sont des colonnes primaires, les
suivantes étant des colonnes secondaires.
Si cet argument est omis, toutes les colonnes sont primaires.
Une fois le problème construit, le module \of{Dlx} fournit
essentiellement trois fonctions pour le résoudre :
\begin{ocaml}
  val get_first_solution: t -> solution
  val iter_solution: (solution -> unit) -> t -> unit
  val count_solutions: t -> int
\end{ocaml}
% en fait, iter_solution est la plus générale ; le dire ?
Le type \of{solution} est un type abstrait. Une fonction est fournie
pour le décoder sous la forme d'une liste d'entiers, représentant les
lignes de la matrice qui ont été sélectionnées. L'idée est ici de ne
pas construire cette liste lorsque cela n'est pas nécessaire.

\paragraph{\of{Zdd}.}
Comme expliqué dans l'introduction, un ZDD est
une structure de donnée représentant une fonction booléenne sur $n$
variables. De manière équivalente, on peut l'interpréter comme un
ensemble de parties de $\{0,1,\dots,n-1\}$, à savoir l'ensemble des
entrées pour lesquelles la fonction booléenne renvoie 1.
Le module \of{Zdd} fournit donc en premier lieu toutes les opérations
de la signature \of{Set.S} pour des éléments étant eux-mêmes des
ensembles d'entiers, c'est-à-dire
\begin{ocaml}
  module S: Set.S with type elt = int
  include Set.S with type elt = S.t
\end{ocaml}
(Contrairement aux BDD, il n'est pas nécessaire de fixer à l'avance
le nombre de variables.)
Parmi les fonctions ensemblistes ci-dessus, on trouve bien évidemment
une fonction \of{cardinal: t -> int}. Cependant, le cardinal d'un ZDD
peut atteindre de très grandes valeurs, comme l'a montré notre exemple
introductif, et il faut donc être également capable de calculer le
cardinal avec un type autre que \of{int}. Pour cela, on propose en
supplément un foncteur
\begin{ocaml}
  module Cardinal(A: ARITH) : sig val cardinal: t -> A.t end
\end{ocaml}
où \of{A} est un module d'arithmétique minimal fournissant un zéro, une unité
et une addition.
Une autre différence avec le module \of{Set} d'OCaml vient de
l'unicité de la représentation d'un ZDD. Elle permet de fournir des
opérations \of{compare} et \of{equal} de complexité $O(1)$.

\InsertBoxR{2}{\includegraphics[scale=0.5]{../stage/imports/zdd_construct2.pdf}}
Par ailleurs, le module \of{Zdd} fournit une interface de plus bas
niveau, qui expose la représentation interne.
Un ZDD est un arbre binaire dont les feuilles sont
\of{Bottom} ou \of{Top} et dont les \noeuds\ internes sont étiquetés
par des entiers. Plutôt que de parler de sous-arbres gauche et droit,
on parle ici de sous-arbres négatif et positif.
L'interprétation ensembliste est alors la suivante~: \of{Bottom} est
l'ensemble vide $\emptyset$~; \of{Top} est le singleton
$\{\emptyset\}$~; et un arbre de racine $i$, de sous-arbre négatif
représentant $S^-$ et de sous-arbre positif représentant $S^+$,
est l'ensemble $S^-\cup\{\{i\}\cup s\,|\,s\in S^+\}$. Ainsi
le ZDD ci-contre représente l'ensemble
$\{\{0\},\{1\},\{2\},\{0,1,2\}\}$, les sous-arbres négatifs étant
représentés en pointillés.
Dit autrement, il y a autant d'éléments que de chemins menant de la
racine à \of{Top}, et chaque descente vers un sous-arbre positif
correspond à un élément sélectionné.
L'unicité de représentation est par ailleurs assurée par les invariants
suivants~: d'une part un sous-arbre positif n'est jamais \of{Bottom}
et d'autre part les étiquettes vont croissantes lorsqu'on descend dans
l'arbre.
Des fonctions d'affichage sont fournies, aux formats ASCII pour la
forme ensembliste et au format DOT pour la représentation sous forme
d'arbre. Le dessin ci-dessus illustre le résultat de la sortie DOT.
%
Enfin,
pour permettre notamment l'écriture de fonctions opérant directement sur les
ZDD, le module \of{Dlx} expose le type \of{t} des ZDD :
\begin{ocaml}
  type t = private Bottom | Top | Node of unique * int * t * t
\end{ocaml}
(Le type \of{unique} représente ici un entier unique, propre à chaque ZDD.)
Le type étant privé, deux valeurs \of{bottom} et \of{top} de type
\of{t} et une fonction \of{construct: int -> t -> t -> t} sont
fournies pour construire des ZDD.

\paragraph{\of{Emc}.}
Le module \of{Emc} est une interface commune aux deux modules \of{Dlx}
et \of{Zdd}, permettant d'utiliser indifféremment l'un ou l'autre sur
un même problème EMC.
Pour cela, il fournit deux modules \of{Emc.D} et \of{Emc.Z} ayant tous les deux
la même interface \of{S} suivante :
\begin{ocaml}
  module type S = sig
    type t
    val create: ?primary:int -> bool array array -> t
    type solution = int list
    val find_solution: t -> solution
    val iter_solution: (solution -> unit) -> t -> unit
    val count_solutions: t -> int
    module Count(A: ARITH): sig val count_solutions: t -> A.t end
  end
\end{ocaml}
Pour DLX, il s'agit d'une simple interface, les fonctionnalités étant
exactement les mêmes. Pour ZDD, en revanche, il faut effectuer une
réduction du problème EMC vers un ZDD, tel que les éléments du ZDD
correspondent exactement aux solutions du problème EMC, c'est-à-dire
aux sous-ensembles de lignes sélectionnées dans la matrice.
On procède comme expliqué dans l'introduction.

\paragraph{\of{Tiling}.} Ce dernier module permet de construire des
problèmes de pavage et de les réduire vers le problème EMC. Pour cela,
il fournit tout d'abord un module \of{Tiling.Pattern} pour décrire des
motifs rectangulaires. Il ne s'agit ni plus ni moins que de matrices
de booléens, munies d'opérations de transformation (redimensionnement,
fusion, isométrie, etc.). Vient ensuite un module \of{Tiling.Tile}
pour décrire les pièces destinées au pavage. Un pièce est la donnée
d'un motif, de sa multiplicité (zéro ou un exemplaire, exactement un
exemplaire, ou une infinité d'exemplaires) et des isométries que l'on
peut appliquer à cette pièce (rotations et/ou réflexions).
Enfin le module \of{Tiling} définit un problème de pavage comme un
motif à paver et une liste de pièces. La fonction \of{Tiling.emc}
réduit un tel problème vers un problème EMC. En particulier, son
résultat permet de décoder toute solution du problème EMC comme une
liste de pièces, avec leurs positions et leurs orientations.

Le module \of{Tiling} utilise un module auxiliaire \of{D4} décrivant
le groupe diédral $D_4$ des 8 isométries du plan qui laissent un carré
invariant. On y trouve la structure de groupe de $D_4$ mais aussi tous ses
sous-groupes. Ce module est d'intérêt général.

\paragraph{Langage d'entrée de l'outil \combine.}
La syntaxe du petit interprète qui vient avec
la bibliothèque \combine\ est résumée figure~\ref{fig:grammaire}.
Un exemple a été donné plus haut, dans la figure~\ref{fig:chameau}.
\begin{figure}[p]
\begin{center}
\begin{tabular}{lrl}
  \nt{decl} & $::=$ &
            \te{pattern} \nt{ident} \te{=} \nt{expr} \\
  &   $|$ & \te{problem} \nt{ident} \te{=} \nt{tiles} \\
  &   $|$ & \te{tiles} \nt{ident} \te{=} \te{[} tile\etoilesep{\te{,}}
            \te{]} \\
  &   $|$ & \te{print} \nt{ident} \\
  &   $|$ & \te{solve} \nt{algo} \nt{ident}
            (\te{ascii} ~\OU~ \te{svg} \nt{string}) \\
  &   $|$ & \te{count} \nt{algo} \nt{ident} \\
  &   $|$ & \te{debug} (\te{on} ~\OU~ \te{off}) \\
  &   $|$ & \te{timing} (\te{on} ~\OU~ \te{off}) \\
  &   $|$ & \te{include} \nt{string} \\
  \nt{algo}  & $::=$ & \te{dlx} ~\OU~ \te{zdd} \\
  \nt{tiles} & $::=$ & \nt{ident} ~\OU~ \te{[} tile\etoilesep{\te{,}} \te{]} \\
  \nt{tile}  & $::=$ & \nt{expr} \nt{option}\etoile \\
  \nt{expr}  & $::=$ & \nt{ident} \\
  &   $|$ & \te{\{} \nt{ascii-art} \te{\}} \\
  &   $|$ & \te{constant} \nt{xy} \nt{bool} \\
  &   $|$ & \nt{expr} (\te{\&\&} ~\OU~ \te{||} ~\OU~ \te{\^{}} ~\OU~
            \te{-}) \nt{expr} \\
  &   $|$ & \te{set} \nt{expr} \nt{xy} \nt{bool} \\
  &   $|$ & \te{crop} \nt{xy} \nt{xy} \nt{expr} \\
  &   $|$ & \te{shift} \nt{expr} \nt{xy} \\
  &   $|$ & \te{resize} \nt{expr} \nt{xy} \\
  &   $|$ & \te{apply} \nt{isometry} \nt{expr} \\
  &   $|$ & \te{(} \nt{expr} \te{)} \\
  \nt{xy}  & $::=$ & \nt{integer} \te{x} \nt{integer} \\
  \nt{option}  & $::=$ & \te{\~{}one} ~\OU~ \te{\~{}maybe} ~\OU~
     \te{\~{}sym} ~\OU~ \te{\~{}rot} \\
  \nt{isometry}  & $::=$ & \te{Id} ~\OU~ \te{Rot90} ~\OU~ \te{Rot180}
  ~\OU~ \te{Rot270} \\
  & $|$ & \te{VertRefl} ~\OU~ \te{HorizRefl} ~\OU~
          \te{Diag1Refl} ~\OU~ \te{Diag2Refl}
\end{tabular}
\end{center}
  \caption{Grammaire des problèmes de pavage.}
  \label{fig:grammaire}
\end{figure}
Donnons un autre exemple avec le problème de
Scott~\cite{scott-pentaminos}. Il s'agit de
dénombrer le nombre de façons de paver la figure suivante
\begin{center}
    \includegraphics{scott_problem.mps}
\end{center}
avec les douze pentaminos, c'est-à-dire les douze pièces suivantes :
\begin{center}
  \includegraphics{penta1.mps}
  \includegraphics{penta2.mps}
  \includegraphics{penta3.mps}
  \includegraphics{penta4.mps}
  \includegraphics{penta5.mps}
  \includegraphics{penta6.mps}
  \includegraphics{penta7.mps}
  \includegraphics{penta8.mps}
  \includegraphics{penta9.mps}
  \includegraphics{penta10.mps}
  \includegraphics{penta11.mps}
  \includegraphics{penta12.mps}
\end{center}
Chaque pièce doit être utilisée une et une seule fois, mais peut être
tournée ou retournée à volonté.
On commence par décrire les douze pièces.
\begin{verbatim}
  pattern I = {*****}

  pattern V = {
  ***
  *
  *
  }
\end{verbatim}
etc. On définit ensuite la liste des douze pentaminos avec, pour
chacun, l'option \verb+~one+ pour indiquer qu'il doit être utilisé une
et une seule fois et l'option \verb+~sym+ pour indiquer qu'il peut
être orienté arbitrairement :
\begin{verbatim}
  tiles pentaminos =
    [ L ~one ~sym, T ~one ~sym, V ~one ~sym, N ~one ~sym,
      Z ~one ~sym, F ~one ~sym, X ~one ~sym, W ~one ~sym,
      P ~one ~sym, I ~one ~sym, Y ~one ~sym, U ~one ~sym ]
\end{verbatim}
Nommer cette liste permettra notamment de réutiliser facilement les
pentaminos dans d'autres problèmes de pavage.
(On notera la présence d'une commande \te{include} dans la grammaire.)
Le motif à paver peut être dessiner en ASCII ou encore défini en
effaçant les quatre points centraux d'un carré $8\times 8$ :
\begin{verbatim}
  pattern scott_board =
    set set set set (constant 8x8 true) 3x3 false 3x4 false 4x3 false 4x4 false
\end{verbatim}
Il ne reste plus qu'à définir le problème de Scott et à dénombrer ses
solutions, par exemple avec l'algorithme DLX :
\begin{verbatim}
  problem scott_problem = scott_board pentaminos
  count dlx scott_problem
\end{verbatim}
On trouve 520 solutions en 5,2 secondes.  Plus subtilement, on peut
éliminer les symétries du problème en ne considérant qu'une
orientation possible pour l'une des pièces n'ayant aucune symétrie
(par exemple \includegraphics[scale=0.5]{penta9.mps}). Il suffit pour
cela de lui retirer l'option \verb+~sym+ dans la définition de la
liste \texttt{pentaminos} ci-dessus. On obtient alors 65 solutions
uniques, en 2,6 secondes.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Réalisation}\label{sec:impl}

Cette section détaille la réalisation des différents modules de la
bibliothèque \combine.

\paragraph{\of{Dlx}.}

   type OCaml, iter sur les listes circulaires doublement chaînées

   travaille en espace constant

\paragraph{\of{Zdd}.}

   hash-consing\cite{ConchonFilliatre06wml}, pointeurs faibles, tables
   de mémoïsation

\paragraph{\of{Emc}.}

  surtout réduction EMC -> ZDD

  suit Knuth~\cite{taocp4a} organ-pipe (exercice ?)

\paragraph{\of{Tiling}.}

 types abstraits


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Conclusion et perspectives}

- Dlx :  matrice creuse (construction efficace quand il y a peu de 1)

- prise en compte des symétries du problème pour réduire l'espace

- autres pbms de pavage : en 3D, non rectangulaires, etc.

- réduction EMC vers SAT (format Dimacs)


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% And do NOT FORGET to include your bibliography for submission
\bibliographystyle{plain}
\bibliography{abbrevs,demons,demons2,demons3,team,crossrefs}

\vfill
\pagebreak
\thispagestyle{colloquetitle}
\cleardoublepage
\end{document}

%%% Local Variables:
%%% mode: latex
%%% ispell-local-dictionary: "francais"
%%% TeX-master: t
%%% End:

% LocalWords:  encodé d'EMC acyclique d'assignations booléenne Minato BDD ZDD
% LocalWords:  EMC booléens pentaminos
