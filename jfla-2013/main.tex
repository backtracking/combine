\documentclass[french,frtypo,twoside,actes,a4paper]{article}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{actes,hyperref,graphicx}

\newcommand{\combine}{\texttt{combine}}
\newcommand{\noeud}{n\oe ud}
\newcommand{\noeuds}{n\oe uds}

\newcommand{\te}[1]{\texttt{#1}}
\newcommand{\nt}[1]{$\langle$\textsl{#1}$\rangle$}
\newcommand{\etoile}{$^{\star}$}
\newcommand{\etoilesep}[1]{$^{\star}_#1$}
\newcommand{\plus}{$^+$}
\newcommand{\plussep}[1]{$^+_#1$}
\newcommand{\OU}{\ensuremath{\mid}}

%% Title page...
\title{\combine\ : une bibliothèque OCaml pour la combinatoire}
\author{Rémy El Sibaïe$^1$
  \& Jean-Christophe Filliâtre$^{2,1}$}
%% Headers for other pages...
\titlehead{\combine\ : une bibliothèque OCaml pour la combinatoire} % for odd pages
\authorhead{R.~El Sibaie \& J.-C. Filliâtre}     % for even pages
\affiliation{\begin{tabular}{rr}        % for institute(s)
    \\ 1:  LRI, Université Paris Sud,
    \\     91405 Orsay CEDEX, France
    \\ 2:  CNRS,
    \\     {\tt remy.el-sibaie@u-psud.fr}
    \\     {\tt jean-christophe.filliatre@lri.fr}
  \end{tabular}}

\input{./insbox}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

\setcounter{page}{1}
\maketitle

\begin{abstract}
  Cet article présente \combine\footnote{Le lecteur perspicace notera
    que \combine\ est à la fois un mot anglais, français et un anagramme
    de << combien >>.}, une bibliothèque OCaml pour la
  combinatoire\footnote{Il s'agit d'un travail réalisé par le premier
    auteur pendant un stage de L3 au LRI, d'avril à juin 2012, sous la
    direction du second auteur.}. Elle fournit deux solutions
  algorithmiquement très différentes au problème de la couverture exacte
  d'une matrice (EMC) : les liens dansants de Knuth et une variante
  des diagrammes de décision binaire appelée ZDD. De très nombreux
  problèmes de combinatoire peuvent être ramenés au problème EMC. La
  bibliothèque \combine\ l'illustre notamment sur l'exemple du pavage
  rectangulaire en dimension 2.
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}

\InsertBoxR{1}{\includegraphics{caml_problem.mps}}
Rien n'est plus excitant en informatique que d'écrire un programme
qui calcule en quelques secondes un résultat qu'on ne pourrait obtenir
sans l'aide d'un ordinateur. La combinatoire est un domaine
particulièrement fertile en la matière. Si certains problèmes se
prêtent volontiers à l'analyse mathématique, comme le nombre total de livres
dans la bibliothèque de Borgès ou encore le nombre de
labyrinthes parfaits rectangulaires, beaucoup d'autres exigent de
recourir à la programmation. Considérons par exemple le
nombre de façons différentes de paver
la figure ci-contre avec des dominos $2\times 1$.
Il est relativement aisé d'écrire un programme qui va explorer toutes
les solutions possibles. En une fraction de seconde, on déterminera
alors qu'elles sont au nombre de 46\,976.
% (ZDD 0.11s, DLX 0.09s)

\InsertBoxL{0}{\includegraphics{caml2_problem.mps}}
Mais considérons maintenant un problème de pavage légèrement plus
complexe, avec la figure de gauche qui demande deux fois plus de dominos.
Le problème est nettement plus difficile. Une approche brutale, qui
trouve les solutions une à une, n'aboutira pas. Il existe en effet
32\,420\,116\,341\,024\,288 solutions distinctes. Même à raison d'un
milliard de solutions trouvées par seconde, il faudrait encore plus
d'un an pour parvenir à ce chiffre. Et pourtant le chiffre ci-dessus a
été obtenu par les auteurs en quelques dizaines de secondes seulement,
à l'aide d'une bibliothèque OCaml, \combine, qui permet notamment de résoudre des
problèmes de pavage rectangulaires en dimension 2.
Cet article a pour but de présenter cette bibliothèque.
% (ZDD 39.7s, 1.4 Go de RAM)

La bibliothèque \combine\ est centrée autour du problème de la
\emph{couverture exacte de matrice}, désigné par EMC dans ce qui suit. Étant
donnée une matrice contenant uniquement des 0 et des 1, il s'agit de
déterminer un sous-ensemble de ses lignes contenant un 1 et un seul
par colonne. Étant donné un problème EMC, on peut s'intéresser
uniquement à la question de savoir s'il possède une solution, au
problème d'en construire une le cas échéant, au problème de dénombrer
les solutions, ou encore au problème de les construire toutes.
Ainsi le problème EMC suivant
\begin{displaymath}
  % \begin{array}{ c }
  %  0. \\
  %  1. \\
  %  2. \\
  %  3. \\
  %  4. \\
  % \end{array}
\left(
  \begin{array}{ c c c c c }
   1 & 0 & 1 & 1 \\
   0 & 1 & 1 & 0 \\
   1 & 1 & 0 & 1 \\
   1 & 0 & 0 & 1 \\
   0 & 1 & 0 & 0
  \end{array} \right)
\end{displaymath}
possède exactement deux solutions, à savoir les sous-ensembles de
lignes $\{0,4\}$ et $\{1,3\}$.
L'intérêt d'EMC est qu'il est très facile d'y encoder de
nombreux problèmes de combinatoire. Ainsi un problème de pavage, tel
que celui présenté en introduction, peut être encodé de la façon
suivante : chaque colonne représente une case à recouvrir et chaque
ligne une façon possible de poser une pièce. Ainsi le petit chameau
donne lieu à une matrice de 80 colonnes et 122 lignes, et le gros
chameau à une matrice de 160 colonnes et 268 lignes.

Pour résoudre le problème EMC, plusieurs techniques sont à notre
disposition. Une première consiste à découvrir les solutions une par
une, en utilisant du \emph{backtracking}.
Knuth a proposé pour cela un algorithme appelé les \emph{liens
  dansants} ou encore DLX~\cite{knuth00:dlx}. Il consiste à relier
ensemble tous les
1 de la matrice EMC dans un réseau de listes circulaires doublement
chaînées horizontales et verticales, puis à ôter
successivement les éléments de ces listes, au fur et à mesure des choix
qui sont faits, et à les réinsérer ensuite.
L'efficacité de cet algorithme est due notamment à la
possibilité de réinsérer un élément qui vient d'être supprimé d'une
liste doublement chaînée sans utiliser d'autre information que
celle qui se trouve déjà dans les deux pointeurs vers ses anciens voisins.
L'algorithme DLX ne trouve les solutions du problème EMC qu'une à une,
mais avec une très grande efficacité. Pour le petit chameau, les
46\,976 solutions sont trouvées en un dixième de seconde.

Une seconde approche du problème EMC consiste à utiliser une variante
des BDD appelée ZDD, pour \emph{Zero-suppressed binary Decision
  Diagram}, et due à Minato~\cite{ZDD}. Comme les BDD, les ZDD
permettent de représenter une fonction booléenne de $n$ variables sous
la forme d'un graphe orienté acyclique. Leur particularité est
d'offrir une représentation plus compacte que les BDD dans certains
cas, et notamment ceux qui nous intéressent ici.
On peut effectuer des
opérations entre ZDD, comme par exemple la conjonction ou la
disjonction, ou encore calculer très simplement le nombre
d'assignations distinctes des $n$ variables qui donne la valeur de
vérité 1. Les ZDD sont décrits en détail dans le volume 4A de
\emph{The Art of Computer Programming}~\cite{taocp4a}.
Le problème EMC peut être réduit à un ZDD de la façon
suivante. Les $n$ variables sont les $n$ lignes de la matrice. On
commence par convertir chaque colonne de la matrice EMC en un ZDD qui
correspond aux sous-ensembles de lignes qui contiennent exactement un
1 dans cette colonne. Puis on fait l'intersection de tous ces
ZDD\footnote{Les ZDD étaient au concours X/ENS en 2012 mais ce n'est,
  bien sûr, que pure coïncidence.}.
Cette technique a les avantages et les inconvénients usuels des BDD. Si on
parvient à construire le ZDD sans épuiser la mémoire vive, alors le
problème est résolu. En effet, on peut alors facilement déterminer
s'il existe une solution, et une construire une le cas échéant, mais
surtout calculer le nombre total de solutions (en exploitant le
partage, comme avec un BDD). C'est ainsi qu'on a calculé le nombre
gigantesque de solutions au problème de pavage du grand chameau, avec
un ZDD de 784\,132 \noeuds.

\InsertBoxR{0}{\includegraphics[scale=0.8]{caml_solution.mps}}%
La bibliothèque \combine\ contient, outre ces deux solutions au problème
EMC, trois exemples d'application. Les deux premiers sont des exemples
relativement simples. Il s'agit du problème des $N$ reines et du
Sudoku. Le troisième exemple est celui du pavage rectangulaire en
dimension 2. Il se présente sous la forme d'une bibliothèque OCaml
pour décrire un problème de pavage, le réduire à un problème EMC et
interpréter les solutions.
C'est ainsi qu'a été obtenue la solution ci-contre\footnote{Ce
  résultat de pavage a été dessiné
  automatiquement avec la
  bibliothèque OCaml \texttt{mlpost}~\cite{mlpost09jfla}, à partir
  de la solution produite par \combine.} au problème de
pavage donné en introduction.
Enfin, la distribution de \combine\ contient un interprète pour un petit
langage permettant de décrire un problème de pavage dans une syntaxe
concrète et d'utiliser les différents outils de la bibliothèque
sans recourir à un programme.
La figure~\ref{fig:chameau} contient un exemple d'entrée pour cet
interprète.
%
\begin{figure}[t]
  \centering
  \begin{tabular}{l|l}
    \begin{minipage}{0.4\linewidth}
\begin{verbatim}
pattern caml = {
....****....................
..******....................
********....****..****......
....****....**********......
....****..**************....
....**********************..
....************************
......********....******..**
........****........****....
........****........****....
........****........****....
........****........****....
........****........****....}
\end{verbatim}
    \end{minipage} &
    \begin{minipage}{0.6\linewidth}
\begin{verbatim}
pattern domino = {**}

problem tiling_a_caml = caml [domino ~sym]

timing on

solve dlx tiling_a_caml svg "output.svg"

count zdd tiling_a_caml





\end{verbatim}
    \end{minipage}
  \end{tabular}
  \caption{Exemple d'entrée de l'outil \combine\ (sur deux colonnes).}
\hrulefill
  \label{fig:chameau}
\end{figure}
%
On y définit deux motifs \of{caml} et \of{domino} en les dessinant en
ASCII. Puis on définit le problème de pavage \of{tiling_a_caml} en
donnant le motif à paver (\of{caml}) et la liste des pièces pour le
paver. Ici cette liste est réduite à \of{domino}. L'option \of{~sym}
indique que la pièce peut être tournée et retournée à volonté, ce qui
ici se réduit à deux façons distinctes de la poser (horizontalement et
verticalement). On demande la résolution du
problème avec l'algorithme DLX (\of{solve dlx}), la solution étant
exportée au format SVG dans un fichier. Enfin, on dénombre les
solutions avec un ZDD (\of{count zdd}).

\insboxrestore
\medskip
Le reste de cet article est organisé de la façon suivante.
La section~\ref{sec:sig} présente l'interface de la bibliothèque \combine\
et la section~\ref{sec:reines} illustre son utilisation sur le
problème des $N$ reines.
La section~\ref{sec:impl} donne ensuite des détails techniques sur la
réalisation des algorithmes DLX et ZDD. La
section~\ref{sec:pavage} décrit l'application au pavage.
L'article s'achève sur quelques extensions possibles.
La bibliothèque \combine\ est un logiciel libre, distribué sous licence
LGPL à l'adresse \url{http://www.lri.fr/~filliatr/combine/}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Interface}\label{sec:sig}

Cette section décrit l'interface des trois modules principaux de \combine, à
savoir \of{Dlx}, \of{Zdd} et \of{Emc}.
% La bibliothèque \combine\ se compose de quatre modules principaux,
% organisés de la façon suivante :
% \begin{center}
%   \includegraphics{archi.mps}
% \end{center}
% Cette section décrit ces quatre modules, de bas en haut.

\paragraph{\of{Dlx}.}
L'algorithme DLX résout le problème EMC.
Un tel problème est ici matérialisé par un type abstrait \of{Dlx.t}, que l'on
construit à partir d'une matrice de booléens.
\begin{ocaml}
  val create: ?primary:int -> bool array array -> t
\end{ocaml}
On généralise légèrement le problème présenté dans
l'introduction, en distinguant des colonnes primaires qui doivent être
couvertes (un 1 et un seul dans ces colonnes-là) et des colonnes
secondaires qui peuvent ne pas être couvertes (au plus un 1).
L'argument optionnel \of{primary} permet de spécifier que les
\of{primary} premières colonnes sont des colonnes primaires, les
suivantes étant des colonnes secondaires.
Si cet argument est omis, toutes les colonnes sont primaires.
Une fois le problème construit, le module \of{Dlx} fournit
une fonction pour parcourir toutes ses solutions
\begin{ocaml}
  val iter_solution: (solution -> unit) -> t -> unit
\end{ocaml}
et en dérive immédiatement deux fonctions pour obtenir une seule
solution (s'il en existe une) et dénombrer les solutions :
\begin{ocaml}
  val get_first_solution: t -> solution
  val count_solutions: t -> int
\end{ocaml}
Le type \of{solution} est un type abstrait. Une fonction est fournie
pour le décoder sous la forme d'une liste d'entiers, représentant les
lignes de la matrice qui ont été sélectionnées. L'idée est ici de ne
pas construire cette liste lorsque cela n'est pas nécessaire.

\paragraph{\of{Zdd}.}
Comme expliqué dans l'introduction, un ZDD est
une structure de donnée représentant une fonction booléenne sur $n$
variables. De manière équivalente, on peut l'interpréter comme un
ensemble de parties de $\{0,1,\dots,n-1\}$, à savoir l'ensemble des
entrées pour lesquelles la fonction booléenne renvoie 1.
Le module \of{Zdd} fournit donc en premier lieu toutes les opérations
de la signature \of{Set.S} pour des éléments étant eux-mêmes des
ensembles d'entiers, c'est-à-dire
\begin{ocaml}
  module S: Set.S with type elt = int
  include Set.S with type elt = S.t
\end{ocaml}
(Contrairement aux BDD, il n'est pas nécessaire de fixer à l'avance
le nombre de variables.)
Parmi les fonctions ensemblistes ci-dessus, on trouve bien évidemment
une fonction \of{cardinal: t -> int}. Cependant, le cardinal d'un ZDD
peut atteindre de très grandes valeurs, comme l'a montré notre exemple
introductif, et il faut donc être également capable de calculer le
cardinal avec un type autre que \of{int}. Pour cela, on propose en
supplément un foncteur
\begin{ocaml}
  module Cardinal(A: ARITH) : sig val cardinal: t -> A.t end
\end{ocaml}
où \of{A} est un module d'arithmétique minimal fournissant un zéro, une unité
et une addition.
Une autre différence avec le module \of{Set} d'OCaml vient de
l'unicité de la représentation d'un ZDD. Elle permet notamment de fournir des
opérations \of{compare} et \of{equal} de complexité $O(1)$.

\InsertBoxR{2}{\includegraphics[scale=0.5]{zdd_construct2.pdf}}
Par ailleurs, le module \of{Zdd} fournit une interface de plus bas
niveau, qui expose la représentation interne.
Un ZDD est un arbre binaire dont les feuilles sont
\of{Bottom} ou \of{Top} et dont les \noeuds\ internes sont étiquetés
par des entiers. Plutôt que de parler de sous-arbres gauche et droit,
on parle ici de sous-arbres négatif et positif.
L'interprétation ensembliste est alors la suivante~: \of{Bottom} est
l'ensemble vide $\emptyset$~; \of{Top} est le singleton
$\{\emptyset\}$~; et un arbre de racine $i$, de sous-arbre négatif
représentant $S^-$ et de sous-arbre positif représentant $S^+$,
est l'ensemble $S^-\cup\{\{i\}\cup s\,|\,s\in S^+\}$. Ainsi
le ZDD ci-contre représente l'ensemble
$\{\{0\},\{1\},\{2\},\{0,1,2\}\}$, les sous-arbres négatifs étant
représentés en pointillés.
Dit autrement, il y a autant d'éléments que de chemins menant de la
racine à \of{Top}, et chaque descente vers un sous-arbre positif
correspond à un élément sélectionné.
L'unicité de représentation est par ailleurs assurée par les invariants
suivants~: d'une part un sous-arbre positif n'est jamais \of{Bottom}
et d'autre part les étiquettes vont croissantes lorsqu'on descend dans
l'arbre.
Des fonctions d'affichage sont fournies, aux formats ASCII pour la
forme ensembliste et au format DOT pour la représentation sous forme
d'arbre. Le dessin ci-dessus illustre le résultat de la sortie DOT.
%
Enfin,
pour permettre notamment l'écriture de fonctions opérant directement sur les
ZDD, le module \of{Zdd} expose le type \of{t} des ZDD :
\begin{ocaml}
  type t = private Bottom | Top | Node of unique * int * t * t
\end{ocaml}
(Le type \of{unique} représente ici un entier unique, propre à chaque ZDD.)
Le type étant privé, deux valeurs \of{bottom} et \of{top} de type
\of{t} et une fonction \of{construct: int -> t -> t -> t} sont
fournies pour construire des ZDD.

\paragraph{\of{Emc}.}
Le module \of{Emc} est une interface commune aux deux modules \of{Dlx}
et \of{Zdd}, permettant d'utiliser indifféremment l'un ou l'autre sur
un même problème EMC.
Pour cela, il fournit deux modules \of{Emc.D} et \of{Emc.Z} ayant tous les deux
la même interface \of{S} suivante :
\begin{ocaml}
  module type S = sig
    type t
    val create: ?primary:int -> bool array array -> t
    type solution = int list
    val find_solution: t -> solution
    val iter_solution: (solution -> unit) -> t -> unit
    val count_solutions: t -> int
    module Count(A: ARITH): sig val count_solutions: t -> A.t end
  end
\end{ocaml}
Pour DLX, il s'agit d'une simple interface, les fonctionnalités étant
exactement les mêmes. Pour ZDD, en revanche, il faut effectuer une
réduction du problème EMC vers un ZDD, tel que les éléments du ZDD
correspondent exactement aux solutions du problème EMC, c'est-à-dire
aux sous-ensembles de lignes sélectionnées dans la matrice.
On procède comme expliqué dans l'introduction.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Exemple d'utilisation : les $N$ reines}\label{sec:reines}

L'article sur les liens dansants~\cite{knuth00:dlx} contient notamment
une application au problème des $N$ reines. On reprend ici cet exemple
pour illustrer l'utilisation de la bibliothèque \combine.
On rappelle que ce problème consiste à déterminer le nombre de façons
de placer $N$ reines sur un échiquier $N\times N$ sans que deux
d'entre elles soient en prise. Voici par exemple l'une des 92
solutions pour $N=8$ :
\begin{center}
  \includegraphics[scale=0.5]{solution8.mps}
\end{center}
On construit une matrice EMC dont les colonnes primaires représentent
les $N$ abscisses et les $N$ ordonnées sur l'échiquier, et
les colonnes secondaires les $2N-1$ diagonales montantes et les $2N-1$
diagonales descendantes. On a donc au total $6N-2$ colonnes, que l'on peut
numéroter de 0 à $6N-3$ de la façon suivante :
\begin{center}
  \begin{tabular}{ccc|ccc|ccc|ccc}
    \multicolumn{6}{c|}{colonnes primaires} &
    \multicolumn{6}{c}{colonnes secondaires} \\
    \multicolumn{3}{c|}{abscisse} &
    \multicolumn{3}{c|}{ordonnée} &
    \multicolumn{3}{c|}{diagonale 1} &
    \multicolumn{3}{c}{diagonale 2} \\
    0 & \dots & $N-1$ & $N$ & \dots & $2N-1$ &
    $2N$ & \dots & $4N-2$ & $4N-1$ & \dots & $6N-3$ \\
    \hline
  \end{tabular}
\end{center}
La matrice EMC contient autant de lignes qu'il y a de cases sur
l'échiquier, soit $N^2$. Pour chaque case $(i,j)$, avec $0\le i,j< N$,
la ligne correspondante de la matrice EMC contient exactement quatre
1, indiquant respectivement l'abscisse, l'ordonnée et les deux
diagonales de la case $(i,j)$. Avec la numérotation ci-dessus, il
s'agit donc des colonnes $i$, $N+j$, $2N+i+j$ et $4N-1+(N-1-i)+j$.
On suppose que la variable OCaml \of{n} contient le nombre $N$.
On commence par écrire une fonction \of{row} qui construit une ligne
de la matrice EMC, comme un tableau de booléens :
\begin{ocaml}
let row i j =
  let f k = k = i || k = n + j || k = 2*n + i + j || k = 4*n-1 + n-1-i + j in
  Array.init (6 * n - 2) f
\end{ocaml}
Puis on construit la matrice EMC en accumulant toutes les lignes
renvoyées par \of{row} dans une liste, puis en transformant au final
la liste en tableau :
\begin{ocaml}
let emc =
  let lr = ref [] in
  for i = 0 to n - 1 do for j = 0 to n - 1 do lr := row i j :: !lr done done;
  Array.of_list !lr
\end{ocaml}
Enfin on définit le nombre de colonnes primaires :
\begin{ocaml}
let primary = 2 * n
\end{ocaml}
Pour dénombrer les solutions avec l'algorithme DLX, on utilise le
module \of{Emc.D}. On crée la structure interne de DLX avec
\of{create} puis on appelle la fonction \of{count_solutions} :
\begin{ocaml}
  let p = Emc.D.create ~primary emc in
  Emc.D.count_solutions p
\end{ocaml}
Si on préfère utiliser les ZDD, on procède exactement de la même
façon, en utilisant le module \of{Emc.Z} au lieu du module \of{Emc.D} :
\begin{ocaml}
  let p = Emc.Z.create ~primary emc in
  Emc.Z.count_solutions p
\end{ocaml}
Les résultats sont données figure~\ref{fig:reines}. On indique
notamment le temps passé dans chaque algorithme et la quantité de
mémoire utilisée. Cette dernière est exclusivement due aux ZDD,
l'algorithme DLX n'utilisant quasiment pas de mémoire sur cet exemple
(pour $N=12$, l'algorithme DLX n'utilise pas plus de 40 ko sur une
machine 64 bits).
\begin{figure}
\begin{center}
  \begin{tabular}{|c|r|r|r|r|r|r|r|}
    \hline
        & nombre de & matrice & temps & taille & temps & mémoire \\
    $N$ & solutions & EMC     & DLX   & ZDD    & ZDD   & max. \\
    \hline\hline
4 &
2 &
16x22 &
0,00 s &
8 &
0,00 s &
3.88 Mo
\\\hline

5 &
10 &
25x28 &
0,00 s &
40 &
0,00 s &
5,81 Mo
\\\hline

6 &
4 &
 36x34 &
 0,00 s &
 24 &
 0,02 s &
 7,75 Mo
\\\hline

7 &
40 &
 49x40 &
 0,00 s &
 186 &
 0,03 s &
 13,56 Mo
\\\hline

8 &
92 &
 64x46 &
 0,00 s &
 373 &
 0,45 s &
 45,48 Mo
\\\hline

9 &
352 &
 81x52 &
 0,00 s &
 1309 &
 0,76 s &
 64,85 Mo
\\\hline

10 &
724 &
 100x58 &
 0,02 s &
 3120 &
 3,56 s &
 221,03 Mo
\\\hline

11 &
2680 &
 121x64 &
 0,07 s &
 10503 &
 14,57 s &
 697,39 Mo
\\\hline

12 &
14200 &
 144x70 &
 0,35 s &
--- & --- & > 2Go
\\\hline

  \end{tabular}
\end{center}
  \caption{Résoudre les $N$ reines avec \combine.}
  \label{fig:reines}
\end{figure}
%
L'article de Knuth va un peu plus loin, en considérant notamment
plusieurs heuristiques pour l'ordre dans lequel les colonnes sont
sélectionnées par l'algorithme DLX.
On peut alors aller assez loin avec l'algorithme DLX (jusqu'à $N=18$).
En revanche, comme on le voit sur la figure, le coût en mémoire des
ZDD est rapidement prohibitif.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Réalisation}\label{sec:impl}

Cette section détaille la réalisation technique des trois modules
\of{Dlx}, \of{Zdd} et \of{Emc}.

\paragraph{\of{Dlx}.}
L'algorithme DLX opère sur un ensemble de listes doublement chaînées
circulaires, qui relient tous les 1 de la matrice EMC horizontalement
et verticalement.
Par ailleurs, chaque colonne de la matrice contient un \noeud\
supplémentaire, appelé entête. Les entêtes sont également liés entre
eux dans une liste chaînée circulaire.
Voici un exemple de matrice et la structure DLX correspondante :
\begin{center}
  \raisebox{7em}{$\left(  \begin{array}{ c c c c c }
   1 & 0 & 1 & 1 \\
   0 & 1 & 1 & 0 \\
   1 & 1 & 0 & 1 \\
   1 & 0 & 0 & 1 \\
   0 & 1 & 0 & 0
  \end{array} \right)$}
\qquad\qquad\qquad
  \includegraphics[scale=0.45]{dlx.mps}
\end{center}
Les pointeurs s'étendent jusqu'aux \noeuds\ suivants,
circulairement. Les entêtes apparaissent en haut.
Chaque \noeud\ est représenté par le type OCaml suivant :
\begin{ocaml}
type node = {
  mutable up:   node; mutable down:  node;
  mutable left: node; mutable right: node;
  mutable c:    node; mutable s:     int;  mutable name: string; }
\end{ocaml}
Les quatre champs \of{up}, \of{down}, \of{left} et \of{right}
matérialisent les deux listes doublement chaînées dont fait partie
chaque \noeud. Le champ \of{c} contient un pointeur vers l'entête de
la colonne (ces pointeurs ne sont pas dessinés dans la figure
ci-dessus, par souci de clarté). Le champ \of{name} contient le nom de
chaque colonne, à des fins d'affichage.
Enfin, l'entier contenu dans le champ \of{s} est interprété ainsi~:
pour un entête, il contient le nombre de \noeuds\ dans la colonne
correspondante et est utilisé pour choisir une colonne minimisant cette
valeur ; pour tout autre \noeud, il contient le numéro de la ligne de
la matrice et est utilisé pour décoder la solution, le cas échéant.

Il est important de préciser une fois encore que l'algorithme DLX
travaille en espace constant~: une fois les \noeuds\ créés à partir de
la matrice, toute la recherche se fait en place, en modifiant seulement
les champs \of{s}, \of{up}, \of{down}, \of{left} et \of{right}. C'est
la danse des liens.
Le pseudo-code de l'algorithme DLX est donné à la fin de cet article
(annexe~\ref{dlx:code}).
Pour plus de détails, on consultera l'article
de Knuth introduisant cet algorithme~\cite{knuth00:dlx}.

\paragraph{\of{Zdd}.}
Le module \of{Zdd} est en tous points analogue à un module de BDD.
Le partage maximal est obtenu par la technique du
\emph{hash-consing}, dont la mise en \oe uvre dans un langage comme
OCaml est établie depuis longtemps~\cite{ConchonFilliatre06wml}.
En particulier, les ZDD déjà construits sont stockés dans une table de
hachage utilisant des pointeurs faibles, ce qui permet au système de
détruire les ZDD qui ne sont plus utilisés nulle part.
Le type OCaml des ZDD est celui qui a déjà été donné plus haut, à savoir
\begin{ocaml}
  type t = Bottom | Top | Node of unique * int * t * t
\end{ocaml}
En particulier, chaque \noeud\ de ZDD occupe exactement 5 mots
mémoire, auxquels s'ajoute son entrée dans la table de
\emph{hash-consing}, c'est-à-dire environ deux mots.

Les différentes opérations sur les ZDD sont mémoïzées. Comme pour les
BDD, c'est là la clé de l'efficacité. Chaque ZDD contenant un
entier unique, il est extrêmement simple de mettre en \oe uvre cette
mémoïzation et elle est de fait très efficace.
Le code effectuant la mémoïzation est factorisé dans des opérateurs de
point fixes. Ainsi le cardinal d'un ZDD s'écrit aussi simplement que
\begin{ocaml}
let cardinal = memo_rec1 (
  fun cardinal -> function
    | Top -> 1
    | Bottom -> 0
    | Node(_, i, z1, z2) -> cardinal z1 + cardinal z2)
\end{ocaml}
et son coût est proportionnel au nombre de \noeuds\ \emph{distincts}
dans le ZDD.

\paragraph{\of{Emc}.}
La seule difficulté du module \of{Emc} est la réduction du problème
EMC en un ZDD. En effet, s'il est facile de construire le ZDD
correspondant à une colonne de la matrice (en temps linéaire, en
procédant de bas en haut), il reste de multiples possibilités pour
effectuer l'intersection de tous ces ZDD et elles ne sont pas toutes
de même coût. Nous avons testé plusieurs solutions et
finalement retenu la solution consistant à trier les colonnes de la
matrice selon la ligne du premier 1 qu'elles contiennent puis
à les fusionner selon la méthode dite \emph{balanced}
proposée par Knuth~\cite[exercice 212 page 274]{taocp4a}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Application au pavage}\label{sec:pavage}

La bibliothèque \combine\ fournit par ailleurs un module \of{Tiling}
pour résoudre des problèmes de pavage rectangulaires en dimension 2,
en les réduisant vers le problème EMC. On a donc l'agencement suivant
des différents modules de \combine~:
\begin{center}
  \includegraphics{archi.mps}
\end{center}

% \paragraph{\of{Tiling}.}
% Il n'y a pas grand chose à dire concernant le module \of{Tiling}, si ce
% n'est que son interface est relativement défensive. La plupart des
% types y sont privés, afin de garantir la validité d'un certain
% nombre de champs d'enregistrements, comme les dimensions d'un motif ou
% encore l'ensemble des symétries d'une pièce.

\paragraph{Interface.}
Le module \of{Tiling}
fournit tout d'abord un sous-module \of{Tiling.Pattern} pour décrire des
motifs rectangulaires. Il ne s'agit ni plus ni moins que de matrices
de booléens, munies d'opérations de transformation (redimensionnement,
fusion, isométrie, etc.). Vient ensuite un module \of{Tiling.Tile}
pour décrire les pièces destinées au pavage. Une pièce est la donnée
d'un motif, de sa multiplicité (zéro ou un exemplaire, exactement un
exemplaire, ou une infinité d'exemplaires) et des isométries que l'on
peut appliquer à cette pièce (rotations et/ou réflexions).
Enfin le module \of{Tiling} définit un problème de pavage comme un
motif à paver et une liste de pièces. La fonction \of{Tiling.emc}
réduit un tel problème vers un problème EMC. En particulier, son
résultat permet de décoder toute solution du problème EMC comme une
liste de pièces, avec leurs positions et leurs orientations.

Le module \of{Tiling} utilise un module auxiliaire \of{D4} décrivant
le groupe diédral $D_4$ des 8 isométries du plan qui laissent un carré
invariant. On y trouve la structure de groupe de $D_4$ mais aussi tous ses
sous-groupes. Ce module est d'intérêt général.

\paragraph{Langage d'entrée de l'outil \combine.}
La syntaxe du petit interprète qui vient avec
la bibliothèque \combine\ est résumée figure~\ref{fig:grammaire}.
Un exemple a été donné plus haut, dans la figure~\ref{fig:chameau}.
\begin{figure}[p]
\begin{center}
\begin{tabular}{lrl}
  \nt{decl} & $::=$ &
            \te{pattern} \nt{ident} \te{=} \nt{expr} \\
  &   $|$ & \te{problem} \nt{ident} \te{=} \nt{tiles} \\
  &   $|$ & \te{tiles} \nt{ident} \te{=} \te{[} tile\etoilesep{\te{,}}
            \te{]} \\
  &   $|$ & \te{print} \nt{ident} \\
  &   $|$ & \te{solve} \nt{algo} \nt{ident}
            (\te{ascii} ~\OU~ \te{svg} \nt{string}) \\
  &   $|$ & \te{count} \nt{algo} \nt{ident} \\
  &   $|$ & \te{debug} (\te{on} ~\OU~ \te{off}) \\
  &   $|$ & \te{timing} (\te{on} ~\OU~ \te{off}) \\
  &   $|$ & \te{include} \nt{string} \\
  \nt{algo}  & $::=$ & \te{dlx} ~\OU~ \te{zdd} \\
  \nt{tiles} & $::=$ & \nt{ident} ~\OU~ \te{[} tile\etoilesep{\te{,}} \te{]} \\
  \nt{tile}  & $::=$ & \nt{expr} \nt{option}\etoile \\
  \nt{expr}  & $::=$ & \nt{ident} \\
  &   $|$ & \te{\{} \nt{ascii-art} \te{\}} \\
  &   $|$ & \te{constant} \nt{xy} \nt{bool} \\
  &   $|$ & \nt{expr} (\te{\&\&} ~\OU~ \te{||} ~\OU~ \te{\^{}} ~\OU~
            \te{-}) \nt{expr} \\
  &   $|$ & \te{set} \nt{expr} \nt{xy} \nt{bool} \\
  &   $|$ & \te{crop} \nt{xy} \nt{xy} \nt{expr} \\
  &   $|$ & \te{shift} \nt{expr} \nt{xy} \\
  &   $|$ & \te{resize} \nt{expr} \nt{xy} \\
  &   $|$ & \te{apply} \nt{isometry} \nt{expr} \\
  &   $|$ & \te{(} \nt{expr} \te{)} \\
  \nt{xy}  & $::=$ & \nt{integer} \te{x} \nt{integer} \\
  \nt{option}  & $::=$ & \te{\~{}one} ~\OU~ \te{\~{}maybe} ~\OU~
     \te{\~{}sym} ~\OU~ \te{\~{}rot} \\
  \nt{isometry}  & $::=$ & \te{Id} ~\OU~ \te{Rot90} ~\OU~ \te{Rot180}
  ~\OU~ \te{Rot270} \\
  & $|$ & \te{VertRefl} ~\OU~ \te{HorizRefl} ~\OU~
          \te{Diag1Refl} ~\OU~ \te{Diag2Refl}
\end{tabular}
\end{center}
  \caption{Grammaire des problèmes de pavage.}
  \label{fig:grammaire}
\end{figure}
Donnons un autre exemple avec le problème de
Scott~\cite{scott-pentaminos}.\label{pbm:Scott} Il s'agit de
dénombrer le nombre de façons de paver la figure suivante
\begin{center}
    \includegraphics{scott_problem.mps}
\end{center}
avec les douze pentaminos, c'est-à-dire les douze pièces suivantes :
\begin{center}
  \includegraphics{penta1.mps}
  \includegraphics{penta2.mps}
  \includegraphics{penta3.mps}
  \includegraphics{penta4.mps}
  \includegraphics{penta5.mps}
  \includegraphics{penta6.mps}
  \includegraphics{penta7.mps}
  \includegraphics{penta8.mps}
  \includegraphics{penta9.mps}
  \includegraphics{penta10.mps}
  \includegraphics{penta11.mps}
  \includegraphics{penta12.mps}
\end{center}
Chaque pièce doit être utilisée une et une seule fois, mais peut être
tournée ou retournée à volonté.
On commence par décrire les douze pièces.
\begin{verbatim}
  pattern I = {*****}

  pattern V = {
  ***
  *
  *
  }
\end{verbatim}
etc. On définit ensuite la liste des douze pentaminos avec, pour
chacun, l'option \verb+~one+ pour indiquer qu'il doit être utilisé une
et une seule fois et l'option \verb+~sym+ pour indiquer qu'il peut
être orienté arbitrairement :
\begin{verbatim}
  tiles pentaminos =
    [ L ~one ~sym, T ~one ~sym, V ~one ~sym, N ~one ~sym,
      Z ~one ~sym, F ~one ~sym, X ~one ~sym, W ~one ~sym,
      P ~one ~sym, I ~one ~sym, Y ~one ~sym, U ~one ~sym ]
\end{verbatim}
Nommer cette liste permettra notamment de réutiliser facilement les
pentaminos dans d'autres problèmes de pavage.
(On notera la présence d'une commande \te{include} dans la grammaire.)
Le motif à paver peut être dessiné en ASCII ou encore défini en
effaçant les quatre points centraux d'un carré $8\times 8$ :
\begin{verbatim}
  pattern scott_board =
    set set set set (constant 8x8 true) 3x3 false 3x4 false 4x3 false 4x4 false
\end{verbatim}
Il ne reste plus qu'à définir le problème de Scott et à dénombrer ses
solutions, par exemple avec l'algorithme DLX :
\begin{verbatim}
  problem scott_problem = scott_board pentaminos
  count dlx scott_problem
\end{verbatim}
On trouve 520 solutions en 5,2 secondes, avec une matrice de 1400 lignes
et 72 colonnes, toutes primaires.  Plus subtilement, on peut
éliminer les symétries du problème en ne considérant qu'une
orientation possible pour l'une des pièces n'ayant aucune symétrie
(par exemple la pièce \includegraphics[scale=0.5]{penta9.mps} dite
F). Il suffit pour
cela de lui retirer l'option \verb+~sym+ dans la définition de la
liste \texttt{pentaminos} ci-dessus. On obtient alors 65 solutions
uniques, en 2,6 secondes.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Conclusion et perspectives}

Nous avons présenté \combine, une bibliothèque OCaml pour la
combinatoire. Elle combine --- c'est le cas de le dire ---
l'algorithme DLX et la structure de ZDD autour du problème unique de la
couverture exacte, et réduit le problème du pavage rectangulaire en
deux dimensions vers ce dernier.

Ce n'est qu'un début. Il est évident que cette bibliothèque pourrait
fournir de nombreuses autres réductions vers le problème EMC, à
commencer par d'autres types de pavage, tels que des pavages en trois
dimensions ou non rectangulaires par exemple.

Concernant le code déjà existant,
une amélioration substantielle du module de pavage consisterait à
prendre en compte les symétries du problème pour réduire l'espace de
recherche.
Dans le problème de Scott décrit plus haut page~\pageref{pbm:Scott},
il était facile de prendre en compte les symétries du problème car
d'une part il existait une pièce ne possédant aucune symétrie et
d'autre part le motif à paver possédait, lui, toutes les
symétries. L'espace de recherche était donc très simplement divisé par
huit.
De manière générale, le problème est plus complexe : on ne dispose pas
nécessairement d'une pièce sans aucune symétrie, elle n'est pas
nécessairement utilisée une fois et une seule, le motif à paver peut
posséder certaines symétries mais pas toutes, etc.

L'interface actuelle du module \of{Dlx} est relativement simpliste, car
elle n'accepte en entrée qu'une matrice de booléens. Or
une matrice EMC est le plus souvent creuse. Par exemple, le pavage par
des dominos conduit à des lignes ne contenant que deux 1.
Il serait donc souhaitable que le module \of{Dlx} accepte également
une description de matrice creuse ou, de façon équivalente, propose une
construction incrémentale de la matrice.

Dans le module \of{Zdd}, un certain nombre de constantes ont été
choisies de manière arbitraire, notamment les tailles initiales des
différentes tables de hachage, et l'utilisateur n'a pas de contrôle
sur ces valeurs. De même, chaque opération sur les ZDD pourrait, au
choix, utiliser une table globale, partagée entre tous les appels à
cette opération, ou bien au contraire une table locale à chaque
appel. Pour l'instant, le choix de tables globales a été fait mais il
serait souhaitable que l'utilisateur puisse choisir au cas par cas.
Toujours dans ce module, les tables de mémoïzation des différentes
opérations n'utilisent pas de pointeurs faibles (au contraire de la
table de \emph{hash-consing}). Par conséquent, elles maintiennent en
vie des ZDD qui pourraient être récupérés par le GC. Pour y remédier,
il faut utiliser des
\emph{éphémérons}~\cite{Hayes:1997:Ephemerons}. Cette technologie est
déjà à l'\oe uvre en OCaml dans l'outil Why3~\cite{why3manual073} et
pourrait donc être mise en place facilement dans \combine.

Enfin, une perspective intéressante consiste à réduire le problème EMC
vers le problème SAT, pour se servir ensuite d'un solveur SAT existant,
à supposer qu'il sache donner une solution ou dénombrer les solutions.
Cette idée a été abordée sur la toute fin du stage, en étendant le
module \of{Emc} d'une sortie au format DIMACS. Il reste cependant à
mener des expériences avec des solveurs SAT pour comparer les
performances avec DLX et ZDD.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\paragraph{Remerciements.} Les auteurs remercient chaleureusement
Claude Marché pour avoir relu une première version de cet article et
pour avoir suggéré de nombreuses améliorations.

% And do NOT FORGET to include your bibliography for submission
% \bibliographystyle{plain}
% \bibliography{abbrevs,demons,demons2,demons3,team,crossrefs}
\begin{thebibliography}{1}

\bibitem{mlpost09jfla}
Romain Bardou, Jean-Christophe Filli\^atre, Johannes Kanig, and St\'ephane
  Lescuyer.
\newblock {Faire bonne figure avec Mlpost}.
\newblock In {\em Vingti\`emes Journ\'ees Francophones des Langages
  Applicatifs}, Saint-Quentin sur Is\`ere, January 2009. INRIA.

\bibitem{why3manual073}
Fran\c{c}ois Bobot, Jean-Christophe Filli\^atre, Claude March\'e, Guillaume
  Melquiond, and Andrei Paskevich.
\newblock {\em The Why3 platform, version 0.73}.
\newblock LRI, CNRS \& Univ. Paris-Sud \& INRIA Saclay, version 0.73 edition,
  July 2012.

\bibitem{ConchonFilliatre06wml}
Sylvain Conchon and Jean-Christophe Filli\^atre.
\newblock {Type-Safe Modular Hash-Consing}.
\newblock In {\em ACM SIGPLAN Workshop on ML}, Portland, Oregon, September
  2006.

\bibitem{Hayes:1997:Ephemerons}
Barry Hayes.
\newblock Ephemerons: a new finalization mechanism.
\newblock {\em SIGPLAN Not.}, 32(10):176--183, October 1997.

\bibitem{ZDD}
Shin ichi Minato.
\newblock Zero-suppressed {BDDs} for set manipulation in combinatorial
  problems.
\newblock In {\em DAC}, pages 272--277, 1993.

\bibitem{knuth00:dlx}
Donald~E. Knuth.
\newblock Dancing links, 2000.
\newblock \url{http://arxiv.org/abs/cs/0011047}.

\bibitem{taocp4a}
Donald~E. Knuth.
\newblock {\em The Art of Computer Programming, volume 4A: Combinatorial
  Algorithms, Part 1}.
\newblock Addison-Wesley Professional, 1st edition, 2011.

\bibitem{scott-pentaminos}
Dana~S. Scott.
\newblock Programming a combinatorial puzzle.
\newblock Technical Report~1, Department of Electrical Engineering, Princeton
  University, 1958.

\end{thebibliography}


\newpage
\appendix
\section{Pseudo-code de l'algorithme DLX (liens dansants)}
\label{dlx:code}

\newcommand{\leftl}{\texttt{.left}}
\newcommand{\rightl}{\texttt{.right}}
\newcommand{\upl}{\texttt{.up}}
\newcommand{\downl}{\texttt{.down}}

L'algorithme DLX est réalisé par une fonction récursive
\textit{search}. Elle prend en argument un indice $k$ qui permet de
remplir un tableau global $S$ avec la solution. Initialement, on
appelle $\textit{search}(0)$.
Le \noeud\ $h$ est l'entête de la liste des (entêtes des) colonnes.

\begin{flushleft}
  \textit{search}($k$) $\equiv$ \\
  \quad si $h\rightl$ \texttt{==} $h$ on a trouvé une solution \\
  \quad sinon, choisir une colonne $c$ \\
  \quad \textit{cover}($c$) \\
  \quad pour chaque $r$ dans $c\downl$, $c\downl\downl$, \dots \\
  \quad \quad $S_k \leftarrow r$ g\\
  \quad \quad pour chaque $j$ dans $r\rightl$, $r\rightl\rightl$, \dots \\
  \quad \quad \quad \textit{cover}($j$) \\
  \quad \quad \textit{search}($k+1$) \\
  \quad \quad pour chaque $j$ dans $r\leftl$, $r\leftl\leftl$, \dots \\
  \quad \quad \quad \textit{uncover}($j$) \\
  \quad \textit{uncover}($c$) 
\end{flushleft}

\noindent La fonction \textit{cover} exprime le fait que la colonne
$c$ est maintenant couverte.

\begin{flushleft}
  \textit{cover}($c$) $\equiv$ \\
  \quad $c\rightl\leftl$ $\leftarrow$ $c\leftl$ \\
  \quad $c\leftl\rightl$ $\leftarrow$ $c\rightl$ \\
  \quad pour chaque $i$ dans $c\downl$, $c\downl\downl$, \dots \\
  \quad \quad pour chaque $j$ dans $i\rightl$, $i\rightl\rightl$, \dots \\
  \quad \quad \quad $j\downl\upl$ $\leftarrow$ $j\upl$ \\
  \quad \quad \quad $j\upl\downl$ $\leftarrow$ $j\downl$
\end{flushleft}

\noindent La fonction \textit{uncover} annule l'effet de la fonction
\textit{cover}. On note que les opérations y sont effectuées dans
l'ordre inverse de la fonction \textit{cover}.

\begin{flushleft}
  \textit{uncover}($c$) $\equiv$ \\
  \quad pour chaque $i$ dans $c\upl$, $c\upl\upl$, \dots \\
  \quad \quad pour chaque $j$ dans $i\leftl$, $i\leftl\leftl$, \dots \\
  \quad \quad \quad $j\downl\upl$ $\leftarrow$ $j$ \\
  \quad \quad \quad $j\upl\downl$ $\leftarrow$ $j$ \\
  \quad $c\rightl\leftl$ $\leftarrow$ $c$ \\
  \quad $c\leftl\rightl$ $\leftarrow$ $c$
\end{flushleft}

\vfill
\pagebreak
\thispagestyle{colloquetitle}
\cleardoublepage
\end{document}

%%% Local Variables:
%%% mode: latex
%%% ispell-local-dictionary: "francais"
%%% TeX-master: t
%%% End:

% LocalWords:  encodé d'EMC acyclique d'assignations booléenne Minato BDD ZDD
% LocalWords:  EMC booléens pentaminos Scott solveur pseudo-code
