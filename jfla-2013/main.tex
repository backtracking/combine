\documentclass[french,frtypo,twoside,actes,a4paper]{article}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{actes,hyperref,graphicx}

\newcommand{\reml}{\texttt{combine}}

%% Title page...
\title{\reml\ : une bibliothèque OCaml pour la combinatoire}
\author{Rémy El Sibaïe$^1$
  \& Jean-Christophe Filliâtre$^{2,1}$}
%% Headers for other pages...
\titlehead{\reml\ : une bibliothèque OCaml pour la combinatoire} % for odd pages
\authorhead{R.~El Sibaie \& J.-C. Filliâtre}     % for even pages
\affiliation{\begin{tabular}{rr}        % for institute(s)
    \\ 1:  LRI, Université Paris Sud,
    \\     91405 Orsay CEDEX, France
    \\ 2:  CNRS,
    \\     {\tt remy.el-sibaie@u-psud.fr}
    \\     {\tt jean-christophe.filliatre@lri.fr}
  \end{tabular}}

\input{./insbox}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

\setcounter{page}{1}
\maketitle

\begin{abstract}
  Cet article présente \reml\footnote{Le lecteur perspicace notera
    que \reml\ est à la fois un mot anglais, français et un anagramme
    de << combien >>.}, une bibliothèque OCaml pour la
  combinatoire\footnote{Il s'agit d'un travail réalisé par le premier
    auteur pendant un stage de L3 au LRI, d'avril à juin 2012, sous la
    direction du second auteur.}. Elle fournit deux solutions
  algorithmiques très différentes au problème de la couverture exacte
  de matrice (EMC) : les liens dansants de Knuth et une variante
  des diagrammes de décision binaire appelée ZDD. De très nombreux
  problèmes de combinatoire peuvent être ramenés au problème EMC. La
  bibliothèque \reml\ l'illustre notamment avec le pavage
  rectangulaire en dimension 2.
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}

\InsertBoxR{1}{\includegraphics{caml_problem.mps}}
Rien n'est plus excitant en informatique que d'écrire un programme
qui calcule en quelques secondes un résultat qu'on ne pourrait obtenir
sans l'aide d'un ordinateur. La combinatoire est un domaine
particulièrement fertile en la matière. Si certains problèmes se
prêtent volontiers à l'analyse mathématique, comme le nombre total de livres
dans la bibliothèque de Borgès ou encore le nombre de
labyrinthes parfaits rectangulaires, beaucoup d'autres exigent de
recourir à la programmation. Considérons par exemple le
nombre de façons différentes de paver
la figure ci-contre avec des dominos $2\times 1$.
Il est relativement aisé d'écrire un programme qui va explorer toutes
les solutions possibles. En une fraction de seconde, on déterminera
alors qu'elles sont au nombre de 46\,976.
% (ZDD 0.11s, DLX 0.09s)

\InsertBoxL{0}{\includegraphics{caml2_problem.mps}}
Mais considérons maintenant un problème de pavage légèrement plus
complexe, avec la figure de gauche qui demande deux fois plus de dominos.
Le problème est nettement plus difficile. Une approche brutale, qui
trouve les solutions une à une, n'aboutira pas. Il existe en effet
32\,420\,116\,341\,024\,288 solutions distinctes. Même à raison d'un
milliard de solutions trouvées par seconde, il faudrait encore plus
d'un an pour parvenir à ce chiffre. Et pourtant le chiffre ci-dessus a
été obtenu par les auteurs en quelques dizaines de secondes seulement,
à l'aide d'une bibliothèque OCaml, \reml, qui permet notamment de résoudre des
problèmes de pavage rectangulaires en dimension 2.
Cet article a pour but de présenter cette bibliothèque.
% (ZDD 39.7s, 1.4 Go de RAM)

La bibliothèque \reml\ est centrée autour du problème de la
\emph{couverture exacte de matrice}, désigné par EMC dans ce qui suit. Étant
donnée une matrice contenant uniquement des 0 et des 1, il s'agit de
déterminer un sous-ensemble de ses lignes contenant un 1 et un seul
par colonne. Étant donné un problème EMC, on peut s'intéresser
uniquement à la question de savoir s'il possède une solution, au
problème d'en construire une le cas échéant, au problème de dénombrer
les solutions, ou encore au problème de les construire toutes.
Ainsi le problème EMC suivant
\begin{displaymath}
  % \begin{array}{ c }
  %  0. \\
  %  1. \\
  %  2. \\
  %  3. \\
  %  4. \\
  % \end{array}
\left(
  \begin{array}{ c c c c c }
   1 & 0 & 1 & 1 \\
   0 & 1 & 1 & 0 \\
   1 & 1 & 0 & 1 \\
   1 & 0 & 0 & 1 \\
   0 & 1 & 0 & 0
  \end{array} \right)
\end{displaymath}
possède exactement deux solutions, à savoir les sous-ensembles de
lignes $\{0,4\}$ et $\{1,3\}$.
L'intérêt d'EMC est qu'il est très facile d'y encoder de
nombreux problèmes de combinatoire. Ainsi un problème de pavage, tel
que celui présenté en introduction, peut être encodé de la façon
suivante : chaque colonne représente une case à recouvrir et chaque
ligne une façon possible de poser une pièce. Ainsi le petit chameau
donne lieu à une matrice de 80 colonnes et 122 lignes, et le gros
chameau à une matrice de 160 colonnes et 268 lignes.

Pour résoudre le problème EMC, plusieurs techniques sont à notre
disposition. Une première consiste à découvrir les solutions une par
une, en utilisant du \emph{backtracking}.
Knuth a proposé pour cela un algorithme appelé les \emph{liens
  dansants} (ou encore DLX)~\cite{knuth00:dlx}. Il consiste à relier
ensemble tous les
1 de la matrice EMC dans un réseau de listes circulaires doublement
chaînées horizontales et verticales, puis à ôter
successivement les éléments de ces listes, au fur et à mesure des choix
qui sont faits, et à les réinsérer ensuite.
L'efficacité de cet algorithme est due notamment à la
possibilité de réinsérer un élément qui vient d'être supprimé d'une
liste doublement chaînée sans utiliser d'autre information que
celle qui se trouve déjà dans les deux pointeurs vers ses anciens voisins.
L'algorithme DLX ne trouve les solutions du problème EMC qu'une à une,
mais avec une très grande efficacité. Pour le petit chameau, les
46\,976 solutions sont trouvées en un dixième de seconde.

Une second approche du problème EMC consiste à utiliser une variante
des BDD appelée ZDD, pour \emph{Zero-suppressed binary Decision
  Diagram}, et due à Minato~\cite{ZDD}. Comme les BDD, les ZDD
permettent de représenter une fonction booléenne de $n$ variables sous
la forme d'un graphe orienté acyclique. On peut effectuer des
opérations entre ZDD, comme par exemple la conjonction ou la
disjonction, ou encore calculer très simplement le nombre
d'assignations distinctes des $n$ variables qui donne la valeur de
vérité 1. Les ZDD sont décrits en détail dans le volume 4A de
\emph{The Art of Computer Programming}~\cite{taocp4a}.
Le problème EMC peut être réduit à un ZDD de la façon
suivante. Les $n$ variables sont les $n$ lignes de la matrice. On
commence par convertir chaque colonne de la matrice EMC en un ZDD qui
correspond aux sous-ensembles de lignes qui contiennent exactement un
1 dans cette colonne. Puis on fait l'intersection de tous ces
ZDD\footnote{Les ZDD étaient au concours X/ENS en 2012 mais ce n'est,
  bien sûr, que pure coïncidence.}.
Cette technique a les avantages et les inconvénients usuels des BDD. Si on
parvient à construire le ZDD sans épuiser la mémoire vive, alors le
problème est résolu. En effet, on peut alors facilement déterminer
s'il existe une solution, et une construire une le cas échéant, mais
surtout calculer le nombre total de solutions (en exploitant le
partage, comme avec un BDD). C'est ainsi qu'on a calculé le nombre
gigantesque de solutions au problème de pavage du grand chameau.

\InsertBoxR{0}{\includegraphics{caml_solution.mps}}%
La bibliothèque \reml\ contient, outre ces deux solutions au problème
EMC, trois exemples d'application. Les deux premiers sont des exemples
relativement simples. Il s'agit du problème des $N$ reines et du
Sudoku. Le troisième exemple est celui du pavage rectangulaire en
dimension 2. Il se présente sous la forme d'une bibliothèque OCaml
pour décrire un problème de pavage, le réduire à un problème EMC et
interpréter les solutions.
C'est ainsi qu'a été obtenue la solution ci-contre au problème de
pavage donné en introduction\footnote{Ce résultat de pavage a été dessiné
  automatiquement avec la
  bibliothèque OCaml \texttt{mlpost}~\cite{mlpost09jfla}, à partir
  de la solution produite par \reml.}.
Enfin, la distribution de \reml\ contient un interprète pour un petit
langage permettant de décrire un problème de pavage dans une syntaxe
concrète et d'utiliser les différents outils de la bibliothèque
sans recourir à un programme.
La figure~\ref{fig:chameau} contient un exemple d'entrée pour cet
interprète.
%
\begin{figure}[t]
  \centering
  \begin{tabular}{l|l}
    \begin{minipage}{0.4\linewidth}
\begin{verbatim}
pattern caml = {
....****....................
..******....................
********....****..****......
....****....**********......
....****..**************....
....**********************..
....************************
......********....******..**
........****........****....
........****........****....
........****........****....
........****........****....
........****........****....}
\end{verbatim}
    \end{minipage} &
    \begin{minipage}{0.6\linewidth}
\begin{verbatim}
pattern domino = {**}

problem tiling_a_caml = caml [domino ~sym]

timing on

solve dlx tiling_a_caml svg "output.svg"

count zdd tiling_a_caml





\end{verbatim}
    \end{minipage}
  \end{tabular}
  \caption{Exemple d'entrée de l'outil \reml\ (sur deux colonnes).}
\hrulefill
  \label{fig:chameau}
\end{figure}
%
La bibliothèque \reml\ est un logiciel libre, distribué sous licence
LGPL à l'adresse \url{http://www.lri.fr/~filliatr/combine/}.

\insboxrestore
\medskip
Le reste de cet article est organisé de façon très simple. La
section~\ref{sec:sig} présente l'interface de la bibliothèque \reml\
et la section~\ref{sec:impl} les détails techniques de sa
réalisation. L'article s'achève en indiquant des extensions possibles.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Interface}\label{sec:sig}

La bibliothèque \reml\ se compose de quatre modules principaux,
organisés de la façon suivante :
\begin{center}
  \includegraphics{archi.mps}
\end{center}
Cette section décrit ces quatre modules, de bas en haut.

\paragraph{\of{Dlx}.}
L'algorithme DLX résout le problème EMC.
Un tel problème est ici matérialisé par un type abstrait \of{Dlx.t}, que l'on
construit à partir d'une matrice de booléens.
\begin{ocaml}
  val create: ?primary:int -> bool array array -> t
\end{ocaml}
On généralise légèrement le problème présenté dans
l'introduction, en distinguant des colonnes primaires qui doivent être
couvertes (un 1 et un seul dans ces colonnes-là) et des colonnes
secondaires qui peuvent ne pas être couvertes (au plus un 1).
L'argument optionnel \of{primary} permet de spécifier que les
\of{primary} premières colonnes sont des colonnes primaires, les
suivantes étant des colonnes secondaires.
Si cet argument est omis, toutes les colonnes sont primaires.
Une fois le problème construit, le module \of{Dlx} fournit
essentiellement trois fonctions pour le résoudre :
\begin{ocaml}
  val get_first_solution: t -> solution
  val iter_solution: (solution -> unit) -> t -> unit
  val count_solutions: t -> int
\end{ocaml}
% en fait, iter_solution est la plus générale ; le dire ?
Le type \of{solution} est un type abstrait. Une fonction est fournie
pour le décoder sous la forme d'une liste d'entiers, représentant les
lignes de la matrice qui ont été sélectionnées. L'idée est ici de ne
pas construire cette liste lorsque cela n'est pas nécessaire.

\paragraph{\of{Zdd}.} Comme expliqué dans l'introduction, un ZDD est
une structure de donnée représentant une fonction booléenne sur $n$
variables. De manière équivalente, on peut l'interpréter comme un
ensemble de parties de $\{0,1,\dots,n-1\}$, à savoir l'ensemble des
entrées pour lesquelles la fonction booléenne renvoie 1.
Le module \of{Zdd} fournit donc en premier lieu toutes les opérations
de la signature \of{Set.S} pour des éléments étant eux-mêmes des
ensembles d'entiers, c'est-à-dire
\begin{ocaml}
  module S: Set.S with type elt = int
  include Set.S with type elt = S.t
\end{ocaml}

- ZDD : ensembles d'ensembles d'entiers / sortie DOT

- différence avec les BDD : pas besoin de fixer $n$

\begin{center}
  \includegraphics[scale=0.5]{../stage/imports/zdd_construct.pdf}
\end{center}

\paragraph{\of{Emc}.}
Le module \of{Emc} est une interface commune aux deux modules \of{Dlx}
et \of{Zdd}, permettant d'utiliser indifféremment l'un ou l'autre sur
un même problème EMC.

\paragraph{\of{Tiling}.}

\paragraph{Langage}

figure~\ref{fig:chameau}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Réalisation}\label{sec:impl} % = détails techniques

- DLX

   type OCaml, iter sur les listes circulaires doublement chaînées

   travaille en espace constant

- ZDD

   hash-consing\cite{ConchonFilliatre06wml}, pointeurs faibles, tables
   de mémoïsation

- EMC

  surtout réduction EMC -> ZDD

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Conclusion et perspectives}

- Dlx :  matrice creuse (construction efficace quand il y a peu de 1)

- prise en compte des symétries du problème pour réduire l'espace

- autres pbms de pavage : en 3D, non rectangulaires, etc.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% And do NOT FORGET to include your bibliography for submission
\bibliographystyle{plain}
\bibliography{abbrevs,demons,demons2,demons3,team,crossrefs}

\vfill
\pagebreak
\thispagestyle{colloquetitle}
\cleardoublepage
\end{document}

%%% Local Variables:
%%% mode: latex
%%% ispell-local-dictionary: "francais"
%%% TeX-master: t
%%% End:

% LocalWords:  encodé d'EMC acyclique d'assignations booléenne Minato BDD ZDD
% LocalWords:  EMC booléens
